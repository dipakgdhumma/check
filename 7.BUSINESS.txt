#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
// Define a structure to represent an edge between two offices
struct Edge {
int source;
int destination;
int cost;
Edge(int s, int d, int c) : source(s), destination(d), cost(c) {}
};
// Function to compare edges based on their cost
bool compareEdges(const Edge& a, const Edge& b) {
return a.cost < b.cost;
}
// Function to find the parent of a vertex in a disjoint set
int findParent(vector<int>& parent, int vertex) {
if (parent[vertex] == vertex) {
return vertex;
}
return findParent(parent, parent[vertex]);
}
// Function to merge two disjoint sets based on their parent
void mergeSets(vector<int>& parent, int u, int v) {
int parentU = findParent(parent, u);
int parentV = findParent(parent, v);
parent[parentV] = parentU;
}
// Function to find the minimum spanning tree using Kruskal's algorithm
vector<Edge> findMinimumSpanningTree(int numVertices, vector<Edge>& edges) {
sort(edges.begin(), edges.end(), compareEdges); // Sort edges by cost
vector<Edge> minimumSpanningTree;
vector<int> parent(numVertices);
for (int i = 0; i < numVertices; ++i) {
parent[i] = i; // Initialize each vertex as a separate set
}
for (const Edge& edge : edges) {
int parentSource = findParent(parent, edge.source);
int parentDest = findParent(parent, edge.destination);
if (parentSource != parentDest) {
minimumSpanningTree.push_back(edge);
mergeSets(parent, parentSource, parentDest);
}
}
return minimumSpanningTree;
}
int main() {
// Example: Offices are represented by vertices, and edges represent phone lines with associated costs

int numVertices = 5;
vector<Edge> edges = {
{0, 1, 10},
{0, 2, 6},
{0, 3, 5},
{1, 3, 15},
{2, 3, 4},
{3, 4, 12}
};
// Find the minimum spanning tree using Kruskal's algorithm
vector<Edge> minimumSpanningTree = findMinimumSpanningTree(numVertices,
edges);
// Output the edges of the minimum spanning tree (minimum-cost set of phone lines)
cout << "Minimum Spanning Tree (Minimum-cost set of phone lines):" << endl;
for (const Edge& edge : minimumSpanningTree) {
cout << edge.source << " - " << edge.destination << " : " << edge.cost << endl;
}
return 0;
}