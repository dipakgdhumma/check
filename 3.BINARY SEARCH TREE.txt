#include <iostream>
#include <queue>
using namespace std;
// Define a node structure for the binary search tree
struct Node {
int data;
Node* left;
Node* right;
Node(int value) : data(value), left(nullptr), right(nullptr) {}
};
// Function to insert a new node into the binary search tree
Node* insert(Node* root, int value) {
if (root == nullptr) {
return new Node(value);
}
if (value < root->data) {
root->left = insert(root->left, value);
} else if (value > root->data) {
root->right = insert(root->right, value);
}
return root;
}
// Function to find the number of nodes in the longest path from the root
int longestPath(Node* root) {
if (root == nullptr) {
return 0;
}
return 1 + max(longestPath(root->left), longestPath(root->right));
}
// Function to find the minimum data value in the tree
int findMin(Node* root) {
if (root == nullptr) {
cerr << "Tree is empty." << endl;
return -1;
}
Node* current = root;
while (current->left != nullptr) {
current = current->left;
}
return current->data;
}
// Function to swap the roles of left and right pointers at every node
void swapChildren(Node* root) {
if (root == nullptr) {
return;
}
Node* temp = root->left;
root->left = root->right;
root->right = temp;
swapChildren(root->left);
swapChildren(root->right);
}
// Function to search for a value in the binary search tree
bool search(Node* root, int value) {
if (root == nullptr) {
return false;
}
if (root->data == value) {
return true;
} else if (value < root->data) {
return search(root->left, value);
} else {
return search(root->right, value);
}
}
// Function to print the tree level by level (Breadth-First Traversal)
void levelOrderTraversal(Node* root) {
if (root == nullptr) {
return;
}
queue<Node*> q;
q.push(root);
while (!q.empty()) {
Node* current = q.front();
q.pop();
cout << current->data << " ";
if (current->left != nullptr) {
q.push(current->left);
}
if (current->right != nullptr) {
q.push(current->right);
}
}
}
int main() {
// Constructing binary search tree
Node* root = nullptr;
int values[] = {50, 30, 70, 20, 40, 60, 80};
for (int value : values) {
root = insert(root, value);
}
// Printing the tree level by level
cout << "Binary Search Tree (Level Order Traversal): ";
levelOrderTraversal(root);
cout << endl;
// i. Insert new node
int newValue = 45;
root = insert(root, newValue);
cout << "Inserted new node with value " << newValue << endl;
// ii. Find number of nodes in the longest path from root
cout << "Number of nodes in longest path from root: " << longestPath(root) << endl;
// iii. Minimum data value found in the tree
cout << "Minimum data value in the tree: " << findMin(root) << endl;
// iv. Change a tree so that the roles of the left and right pointers are swapped at every node
swapChildren(root);
cout << "Binary Search Tree after swapping left and right pointers at every node: ";
levelOrderTraversal(root);
cout << endl;
// v. Search a value
int searchValue = 60;
if (search(root, searchValue)) {
cout << searchValue << " is found in the tree." << endl;
} else {
cout << searchValue << " is not found in the tree." << endl;
}
return 0;
}